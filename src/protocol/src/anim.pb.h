// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anim.proto

#ifndef PROTOBUF_anim_2eproto__INCLUDED
#define PROTOBUF_anim_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace framework {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_anim_2eproto();
void protobuf_AssignDesc_anim_2eproto();
void protobuf_ShutdownFile_anim_2eproto();

class Rect;
class Point;
class Color;
class Element;
class Keyframe;
class Layer;
class AnimationKeyframe;
class Animation;
class Symbol;
class Anim;
class AnimIndexItem;
class AnimIndex;
class Frame;
class FrameList;

enum Element_ElementType {
  Element_ElementType_ND_MOVIECLIP = 1,
  Element_ElementType_ND_BITMAP = 2,
  Element_ElementType_ND_TTFTEXT = 4,
  Element_ElementType_ND_FRAME = 7,
  Element_ElementType_ND_RECT = 8,
  Element_ElementType_ND_BMTEXT = 9,
  Element_ElementType_ND_PARTICLE = 11
};
bool Element_ElementType_IsValid(int value);
const Element_ElementType Element_ElementType_ElementType_MIN = Element_ElementType_ND_MOVIECLIP;
const Element_ElementType Element_ElementType_ElementType_MAX = Element_ElementType_ND_PARTICLE;
const int Element_ElementType_ElementType_ARRAYSIZE = Element_ElementType_ElementType_MAX + 1;

// ===================================================================

class Rect : public ::google::protobuf::MessageLite {
 public:
  Rect();
  virtual ~Rect();
  
  Rect(const Rect& from);
  
  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Rect& default_instance();
  
  void Swap(Rect* other);
  
  // implements Message ----------------------------------------------
  
  Rect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float w = 3;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 3;
  inline float w() const;
  inline void set_w(float value);
  
  // required float h = 4;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 4;
  inline float h() const;
  inline void set_h(float value);
  
  // @@protoc_insertion_point(class_scope:framework.Rect)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  
  float x_;
  float y_;
  float w_;
  float h_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Rect* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::MessageLite {
 public:
  Point();
  virtual ~Point();
  
  Point(const Point& from);
  
  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Point& default_instance();
  
  void Swap(Point* other);
  
  // implements Message ----------------------------------------------
  
  Point* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // @@protoc_insertion_point(class_scope:framework.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  float x_;
  float y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Color : public ::google::protobuf::MessageLite {
 public:
  Color();
  virtual ~Color();
  
  Color(const Color& from);
  
  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Color& default_instance();
  
  void Swap(Color* other);
  
  // implements Message ----------------------------------------------
  
  Color* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 r = 1;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 1;
  inline ::google::protobuf::int32 r() const;
  inline void set_r(::google::protobuf::int32 value);
  
  // required int32 g = 2;
  inline bool has_g() const;
  inline void clear_g();
  static const int kGFieldNumber = 2;
  inline ::google::protobuf::int32 g() const;
  inline void set_g(::google::protobuf::int32 value);
  
  // required int32 b = 3;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 3;
  inline ::google::protobuf::int32 b() const;
  inline void set_b(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:framework.Color)
 private:
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_b();
  inline void clear_has_b();
  
  ::google::protobuf::int32 r_;
  ::google::protobuf::int32 g_;
  ::google::protobuf::int32 b_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Color* default_instance_;
};
// -------------------------------------------------------------------

class Element : public ::google::protobuf::MessageLite {
 public:
  Element();
  virtual ~Element();
  
  Element(const Element& from);
  
  inline Element& operator=(const Element& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Element& default_instance();
  
  void Swap(Element* other);
  
  // implements Message ----------------------------------------------
  
  Element* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Element& from);
  void MergeFrom(const Element& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef Element_ElementType ElementType;
  static const ElementType ND_MOVIECLIP = Element_ElementType_ND_MOVIECLIP;
  static const ElementType ND_BITMAP = Element_ElementType_ND_BITMAP;
  static const ElementType ND_TTFTEXT = Element_ElementType_ND_TTFTEXT;
  static const ElementType ND_FRAME = Element_ElementType_ND_FRAME;
  static const ElementType ND_RECT = Element_ElementType_ND_RECT;
  static const ElementType ND_BMTEXT = Element_ElementType_ND_BMTEXT;
  static const ElementType ND_PARTICLE = Element_ElementType_ND_PARTICLE;
  static inline bool ElementType_IsValid(int value) {
    return Element_ElementType_IsValid(value);
  }
  static const ElementType ElementType_MIN =
    Element_ElementType_ElementType_MIN;
  static const ElementType ElementType_MAX =
    Element_ElementType_ElementType_MAX;
  static const int ElementType_ARRAYSIZE =
    Element_ElementType_ElementType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .framework.Element.ElementType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::framework::Element_ElementType type() const;
  inline void set_type(::framework::Element_ElementType value);
  
  // required .framework.Point position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::framework::Point& position() const;
  inline ::framework::Point* mutable_position();
  inline ::framework::Point* release_position();
  
  // required .framework.Rect boundingBox = 3;
  inline bool has_boundingbox() const;
  inline void clear_boundingbox();
  static const int kBoundingBoxFieldNumber = 3;
  inline const ::framework::Rect& boundingbox() const;
  inline ::framework::Rect* mutable_boundingbox();
  inline ::framework::Rect* release_boundingbox();
  
  // optional string libName = 4;
  inline bool has_libname() const;
  inline void clear_libname();
  static const int kLibNameFieldNumber = 4;
  inline const ::std::string& libname() const;
  inline void set_libname(const ::std::string& value);
  inline void set_libname(const char* value);
  inline void set_libname(const char* value, size_t size);
  inline ::std::string* mutable_libname();
  inline ::std::string* release_libname();
  
  // optional string instanceName = 5;
  inline bool has_instancename() const;
  inline void clear_instancename();
  static const int kInstanceNameFieldNumber = 5;
  inline const ::std::string& instancename() const;
  inline void set_instancename(const ::std::string& value);
  inline void set_instancename(const char* value);
  inline void set_instancename(const char* value, size_t size);
  inline ::std::string* mutable_instancename();
  inline ::std::string* release_instancename();
  
  // optional float rotation = 6;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 6;
  inline float rotation() const;
  inline void set_rotation(float value);
  
  // optional .framework.Point anchorPoint = 7;
  inline bool has_anchorpoint() const;
  inline void clear_anchorpoint();
  static const int kAnchorPointFieldNumber = 7;
  inline const ::framework::Point& anchorpoint() const;
  inline ::framework::Point* mutable_anchorpoint();
  inline ::framework::Point* release_anchorpoint();
  
  // optional .framework.Point scaleValue = 8;
  inline bool has_scalevalue() const;
  inline void clear_scalevalue();
  static const int kScaleValueFieldNumber = 8;
  inline const ::framework::Point& scalevalue() const;
  inline ::framework::Point* mutable_scalevalue();
  inline ::framework::Point* release_scalevalue();
  
  // optional int32 alpha = 9 [default = 255];
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 9;
  inline ::google::protobuf::int32 alpha() const;
  inline void set_alpha(::google::protobuf::int32 value);
  
  // optional .framework.Color color = 10;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 10;
  inline const ::framework::Color& color() const;
  inline ::framework::Color* mutable_color();
  inline ::framework::Color* release_color();
  
  // optional string text = 11;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 11;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // optional int32 fontSize = 12 [default = 12];
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 12;
  inline ::google::protobuf::int32 fontsize() const;
  inline void set_fontsize(::google::protobuf::int32 value);
  
  // optional string fnt = 13;
  inline bool has_fnt() const;
  inline void clear_fnt();
  static const int kFntFieldNumber = 13;
  inline const ::std::string& fnt() const;
  inline void set_fnt(const ::std::string& value);
  inline void set_fnt(const char* value);
  inline void set_fnt(const char* value, size_t size);
  inline ::std::string* mutable_fnt();
  inline ::std::string* release_fnt();
  
  // optional int32 alignment = 14;
  inline bool has_alignment() const;
  inline void clear_alignment();
  static const int kAlignmentFieldNumber = 14;
  inline ::google::protobuf::int32 alignment() const;
  inline void set_alignment(::google::protobuf::int32 value);
  
  // optional .framework.Point skew = 15;
  inline bool has_skew() const;
  inline void clear_skew();
  static const int kSkewFieldNumber = 15;
  inline const ::framework::Point& skew() const;
  inline ::framework::Point* mutable_skew();
  inline ::framework::Point* release_skew();
  
  // @@protoc_insertion_point(class_scope:framework.Element)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_boundingbox();
  inline void clear_has_boundingbox();
  inline void set_has_libname();
  inline void clear_has_libname();
  inline void set_has_instancename();
  inline void clear_has_instancename();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_anchorpoint();
  inline void clear_has_anchorpoint();
  inline void set_has_scalevalue();
  inline void clear_has_scalevalue();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_fnt();
  inline void clear_has_fnt();
  inline void set_has_alignment();
  inline void clear_has_alignment();
  inline void set_has_skew();
  inline void clear_has_skew();
  
  ::framework::Point* position_;
  ::framework::Rect* boundingbox_;
  int type_;
  float rotation_;
  ::std::string* libname_;
  ::std::string* instancename_;
  ::framework::Point* anchorpoint_;
  ::framework::Point* scalevalue_;
  ::framework::Color* color_;
  ::google::protobuf::int32 alpha_;
  ::google::protobuf::int32 fontsize_;
  ::std::string* text_;
  ::std::string* fnt_;
  ::framework::Point* skew_;
  ::google::protobuf::int32 alignment_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Element* default_instance_;
};
// -------------------------------------------------------------------

class Keyframe : public ::google::protobuf::MessageLite {
 public:
  Keyframe();
  virtual ~Keyframe();
  
  Keyframe(const Keyframe& from);
  
  inline Keyframe& operator=(const Keyframe& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Keyframe& default_instance();
  
  void Swap(Keyframe* other);
  
  // implements Message ----------------------------------------------
  
  Keyframe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Keyframe& from);
  void MergeFrom(const Keyframe& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 startFrame = 1;
  inline bool has_startframe() const;
  inline void clear_startframe();
  static const int kStartFrameFieldNumber = 1;
  inline ::google::protobuf::int32 startframe() const;
  inline void set_startframe(::google::protobuf::int32 value);
  
  // optional bool isMotion = 5 [default = false];
  inline bool has_ismotion() const;
  inline void clear_ismotion();
  static const int kIsMotionFieldNumber = 5;
  inline bool ismotion() const;
  inline void set_ismotion(bool value);
  
  // repeated .framework.Element elements = 3;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 3;
  inline const ::framework::Element& elements(int index) const;
  inline ::framework::Element* mutable_elements(int index);
  inline ::framework::Element* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::framework::Element >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::framework::Element >*
      mutable_elements();
  
  // optional int32 duration = 4 [default = 1];
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);
  
  // optional string script = 6;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 6;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // @@protoc_insertion_point(class_scope:framework.Keyframe)
 private:
  inline void set_has_startframe();
  inline void clear_has_startframe();
  inline void set_has_ismotion();
  inline void clear_has_ismotion();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_script();
  inline void clear_has_script();
  
  ::google::protobuf::int32 startframe_;
  bool ismotion_;
  ::google::protobuf::RepeatedPtrField< ::framework::Element > elements_;
  ::std::string* script_;
  ::google::protobuf::int32 duration_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Keyframe* default_instance_;
};
// -------------------------------------------------------------------

class Layer : public ::google::protobuf::MessageLite {
 public:
  Layer();
  virtual ~Layer();
  
  Layer(const Layer& from);
  
  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Layer& default_instance();
  
  void Swap(Layer* other);
  
  // implements Message ----------------------------------------------
  
  Layer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Layer& from);
  void MergeFrom(const Layer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .framework.Keyframe keyframes = 1;
  inline int keyframes_size() const;
  inline void clear_keyframes();
  static const int kKeyframesFieldNumber = 1;
  inline const ::framework::Keyframe& keyframes(int index) const;
  inline ::framework::Keyframe* mutable_keyframes(int index);
  inline ::framework::Keyframe* add_keyframes();
  inline const ::google::protobuf::RepeatedPtrField< ::framework::Keyframe >&
      keyframes() const;
  inline ::google::protobuf::RepeatedPtrField< ::framework::Keyframe >*
      mutable_keyframes();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:framework.Layer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::RepeatedPtrField< ::framework::Keyframe > keyframes_;
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Layer* default_instance_;
};
// -------------------------------------------------------------------

class AnimationKeyframe : public ::google::protobuf::MessageLite {
 public:
  AnimationKeyframe();
  virtual ~AnimationKeyframe();
  
  AnimationKeyframe(const AnimationKeyframe& from);
  
  inline AnimationKeyframe& operator=(const AnimationKeyframe& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AnimationKeyframe& default_instance();
  
  void Swap(AnimationKeyframe* other);
  
  // implements Message ----------------------------------------------
  
  AnimationKeyframe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnimationKeyframe& from);
  void MergeFrom(const AnimationKeyframe& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 startFrame = 1;
  inline bool has_startframe() const;
  inline void clear_startframe();
  static const int kStartFrameFieldNumber = 1;
  inline ::google::protobuf::int32 startframe() const;
  inline void set_startframe(::google::protobuf::int32 value);
  
  // optional bool isMotion = 2 [default = false];
  inline bool has_ismotion() const;
  inline void clear_ismotion();
  static const int kIsMotionFieldNumber = 2;
  inline bool ismotion() const;
  inline void set_ismotion(bool value);
  
  // required .framework.Point position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::framework::Point& position() const;
  inline ::framework::Point* mutable_position();
  inline ::framework::Point* release_position();
  
  // optional int32 duration = 4 [default = 1];
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);
  
  // optional string script = 5;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 5;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // @@protoc_insertion_point(class_scope:framework.AnimationKeyframe)
 private:
  inline void set_has_startframe();
  inline void clear_has_startframe();
  inline void set_has_ismotion();
  inline void clear_has_ismotion();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_script();
  inline void clear_has_script();
  
  ::google::protobuf::int32 startframe_;
  bool ismotion_;
  ::framework::Point* position_;
  ::std::string* script_;
  ::google::protobuf::int32 duration_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static AnimationKeyframe* default_instance_;
};
// -------------------------------------------------------------------

class Animation : public ::google::protobuf::MessageLite {
 public:
  Animation();
  virtual ~Animation();
  
  Animation(const Animation& from);
  
  inline Animation& operator=(const Animation& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Animation& default_instance();
  
  void Swap(Animation* other);
  
  // implements Message ----------------------------------------------
  
  Animation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Animation& from);
  void MergeFrom(const Animation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .framework.AnimationKeyframe keyframes = 1;
  inline int keyframes_size() const;
  inline void clear_keyframes();
  static const int kKeyframesFieldNumber = 1;
  inline const ::framework::AnimationKeyframe& keyframes(int index) const;
  inline ::framework::AnimationKeyframe* mutable_keyframes(int index);
  inline ::framework::AnimationKeyframe* add_keyframes();
  inline const ::google::protobuf::RepeatedPtrField< ::framework::AnimationKeyframe >&
      keyframes() const;
  inline ::google::protobuf::RepeatedPtrField< ::framework::AnimationKeyframe >*
      mutable_keyframes();
  
  // @@protoc_insertion_point(class_scope:framework.Animation)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::framework::AnimationKeyframe > keyframes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Animation* default_instance_;
};
// -------------------------------------------------------------------

class Symbol : public ::google::protobuf::MessageLite {
 public:
  Symbol();
  virtual ~Symbol();
  
  Symbol(const Symbol& from);
  
  inline Symbol& operator=(const Symbol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Symbol& default_instance();
  
  void Swap(Symbol* other);
  
  // implements Message ----------------------------------------------
  
  Symbol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Symbol& from);
  void MergeFrom(const Symbol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .framework.Rect boundingBox = 2;
  inline bool has_boundingbox() const;
  inline void clear_boundingbox();
  static const int kBoundingBoxFieldNumber = 2;
  inline const ::framework::Rect& boundingbox() const;
  inline ::framework::Rect* mutable_boundingbox();
  inline ::framework::Rect* release_boundingbox();
  
  // required int32 frameCount = 3;
  inline bool has_framecount() const;
  inline void clear_framecount();
  static const int kFrameCountFieldNumber = 3;
  inline ::google::protobuf::int32 framecount() const;
  inline void set_framecount(::google::protobuf::int32 value);
  
  // repeated .framework.Layer layers = 5;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 5;
  inline const ::framework::Layer& layers(int index) const;
  inline ::framework::Layer* mutable_layers(int index);
  inline ::framework::Layer* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::framework::Layer >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::framework::Layer >*
      mutable_layers();
  
  // repeated .framework.Animation anis = 9;
  inline int anis_size() const;
  inline void clear_anis();
  static const int kAnisFieldNumber = 9;
  inline const ::framework::Animation& anis(int index) const;
  inline ::framework::Animation* mutable_anis(int index);
  inline ::framework::Animation* add_anis();
  inline const ::google::protobuf::RepeatedPtrField< ::framework::Animation >&
      anis() const;
  inline ::google::protobuf::RepeatedPtrField< ::framework::Animation >*
      mutable_anis();
  
  // optional int32 frameRate = 10;
  inline bool has_framerate() const;
  inline void clear_framerate();
  static const int kFrameRateFieldNumber = 10;
  inline ::google::protobuf::int32 framerate() const;
  inline void set_framerate(::google::protobuf::int32 value);
  
  // optional float pauseTime = 11;
  inline bool has_pausetime() const;
  inline void clear_pausetime();
  static const int kPauseTimeFieldNumber = 11;
  inline float pausetime() const;
  inline void set_pausetime(float value);
  
  // @@protoc_insertion_point(class_scope:framework.Symbol)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_boundingbox();
  inline void clear_has_boundingbox();
  inline void set_has_framecount();
  inline void clear_has_framecount();
  inline void set_has_framerate();
  inline void clear_has_framerate();
  inline void set_has_pausetime();
  inline void clear_has_pausetime();
  
  ::std::string* name_;
  ::framework::Rect* boundingbox_;
  ::google::protobuf::RepeatedPtrField< ::framework::Layer > layers_;
  ::google::protobuf::int32 framecount_;
  ::google::protobuf::int32 framerate_;
  ::google::protobuf::RepeatedPtrField< ::framework::Animation > anis_;
  float pausetime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Symbol* default_instance_;
};
// -------------------------------------------------------------------

class Anim : public ::google::protobuf::MessageLite {
 public:
  Anim();
  virtual ~Anim();
  
  Anim(const Anim& from);
  
  inline Anim& operator=(const Anim& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Anim& default_instance();
  
  void Swap(Anim* other);
  
  // implements Message ----------------------------------------------
  
  Anim* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Anim& from);
  void MergeFrom(const Anim& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .framework.Symbol symbols = 1;
  inline int symbols_size() const;
  inline void clear_symbols();
  static const int kSymbolsFieldNumber = 1;
  inline const ::framework::Symbol& symbols(int index) const;
  inline ::framework::Symbol* mutable_symbols(int index);
  inline ::framework::Symbol* add_symbols();
  inline const ::google::protobuf::RepeatedPtrField< ::framework::Symbol >&
      symbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::framework::Symbol >*
      mutable_symbols();
  
  // @@protoc_insertion_point(class_scope:framework.Anim)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::framework::Symbol > symbols_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Anim* default_instance_;
};
// -------------------------------------------------------------------

class AnimIndexItem : public ::google::protobuf::MessageLite {
 public:
  AnimIndexItem();
  virtual ~AnimIndexItem();
  
  AnimIndexItem(const AnimIndexItem& from);
  
  inline AnimIndexItem& operator=(const AnimIndexItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AnimIndexItem& default_instance();
  
  void Swap(AnimIndexItem* other);
  
  // implements Message ----------------------------------------------
  
  AnimIndexItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnimIndexItem& from);
  void MergeFrom(const AnimIndexItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated string symbols = 2;
  inline int symbols_size() const;
  inline void clear_symbols();
  static const int kSymbolsFieldNumber = 2;
  inline const ::std::string& symbols(int index) const;
  inline ::std::string* mutable_symbols(int index);
  inline void set_symbols(int index, const ::std::string& value);
  inline void set_symbols(int index, const char* value);
  inline void set_symbols(int index, const char* value, size_t size);
  inline ::std::string* add_symbols();
  inline void add_symbols(const ::std::string& value);
  inline void add_symbols(const char* value);
  inline void add_symbols(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& symbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_symbols();
  
  // @@protoc_insertion_point(class_scope:framework.AnimIndexItem)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> symbols_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static AnimIndexItem* default_instance_;
};
// -------------------------------------------------------------------

class AnimIndex : public ::google::protobuf::MessageLite {
 public:
  AnimIndex();
  virtual ~AnimIndex();
  
  AnimIndex(const AnimIndex& from);
  
  inline AnimIndex& operator=(const AnimIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AnimIndex& default_instance();
  
  void Swap(AnimIndex* other);
  
  // implements Message ----------------------------------------------
  
  AnimIndex* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnimIndex& from);
  void MergeFrom(const AnimIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .framework.AnimIndexItem anims = 1;
  inline int anims_size() const;
  inline void clear_anims();
  static const int kAnimsFieldNumber = 1;
  inline const ::framework::AnimIndexItem& anims(int index) const;
  inline ::framework::AnimIndexItem* mutable_anims(int index);
  inline ::framework::AnimIndexItem* add_anims();
  inline const ::google::protobuf::RepeatedPtrField< ::framework::AnimIndexItem >&
      anims() const;
  inline ::google::protobuf::RepeatedPtrField< ::framework::AnimIndexItem >*
      mutable_anims();
  
  // @@protoc_insertion_point(class_scope:framework.AnimIndex)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::framework::AnimIndexItem > anims_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static AnimIndex* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::MessageLite {
 public:
  Frame();
  virtual ~Frame();
  
  Frame(const Frame& from);
  
  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Frame& default_instance();
  
  void Swap(Frame* other);
  
  // implements Message ----------------------------------------------
  
  Frame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // required int32 w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);
  
  // required int32 h = 5;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 5;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);
  
  // required bool rotated = 6;
  inline bool has_rotated() const;
  inline void clear_rotated();
  static const int kRotatedFieldNumber = 6;
  inline bool rotated() const;
  inline void set_rotated(bool value);
  
  // required int32 filename = 7;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 7;
  inline ::google::protobuf::int32 filename() const;
  inline void set_filename(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:framework.Frame)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_rotated();
  inline void clear_has_rotated();
  inline void set_has_filename();
  inline void clear_has_filename();
  
  ::std::string* name_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  bool rotated_;
  ::google::protobuf::int32 filename_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// -------------------------------------------------------------------

class FrameList : public ::google::protobuf::MessageLite {
 public:
  FrameList();
  virtual ~FrameList();
  
  FrameList(const FrameList& from);
  
  inline FrameList& operator=(const FrameList& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FrameList& default_instance();
  
  void Swap(FrameList* other);
  
  // implements Message ----------------------------------------------
  
  FrameList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FrameList& from);
  void MergeFrom(const FrameList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .framework.Frame frames = 1;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 1;
  inline const ::framework::Frame& frames(int index) const;
  inline ::framework::Frame* mutable_frames(int index);
  inline ::framework::Frame* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::framework::Frame >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::framework::Frame >*
      mutable_frames();
  
  // repeated string filenames = 2;
  inline int filenames_size() const;
  inline void clear_filenames();
  static const int kFilenamesFieldNumber = 2;
  inline const ::std::string& filenames(int index) const;
  inline ::std::string* mutable_filenames(int index);
  inline void set_filenames(int index, const ::std::string& value);
  inline void set_filenames(int index, const char* value);
  inline void set_filenames(int index, const char* value, size_t size);
  inline ::std::string* add_filenames();
  inline void add_filenames(const ::std::string& value);
  inline void add_filenames(const char* value);
  inline void add_filenames(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& filenames() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filenames();
  
  // @@protoc_insertion_point(class_scope:framework.FrameList)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::framework::Frame > frames_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filenames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_anim_2eproto();
  friend void protobuf_AssignDesc_anim_2eproto();
  friend void protobuf_ShutdownFile_anim_2eproto();
  
  void InitAsDefaultInstance();
  static FrameList* default_instance_;
};
// ===================================================================


// ===================================================================

// Rect

// required float x = 1;
inline bool Rect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Rect::x() const {
  return x_;
}
inline void Rect::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Rect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Rect::y() const {
  return y_;
}
inline void Rect::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float w = 3;
inline bool Rect::has_w() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::set_has_w() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect::clear_has_w() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Rect::w() const {
  return w_;
}
inline void Rect::set_w(float value) {
  set_has_w();
  w_ = value;
}

// required float h = 4;
inline bool Rect::has_h() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_h() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect::clear_has_h() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline float Rect::h() const {
  return h_;
}
inline void Rect::set_h(float value) {
  set_has_h();
  h_ = value;
}

// -------------------------------------------------------------------

// Point

// required float x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point::x() const {
  return x_;
}
inline void Point::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point::y() const {
  return y_;
}
inline void Point::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Color

// required int32 r = 1;
inline bool Color::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Color::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Color::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Color::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline ::google::protobuf::int32 Color::r() const {
  return r_;
}
inline void Color::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
}

// required int32 g = 2;
inline bool Color::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Color::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Color::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Color::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline ::google::protobuf::int32 Color::g() const {
  return g_;
}
inline void Color::set_g(::google::protobuf::int32 value) {
  set_has_g();
  g_ = value;
}

// required int32 b = 3;
inline bool Color::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Color::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Color::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Color::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline ::google::protobuf::int32 Color::b() const {
  return b_;
}
inline void Color::set_b(::google::protobuf::int32 value) {
  set_has_b();
  b_ = value;
}

// -------------------------------------------------------------------

// Element

// required .framework.Element.ElementType type = 1;
inline bool Element::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Element::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Element::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Element::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::framework::Element_ElementType Element::type() const {
  return static_cast< ::framework::Element_ElementType >(type_);
}
inline void Element::set_type(::framework::Element_ElementType value) {
  GOOGLE_DCHECK(::framework::Element_ElementType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .framework.Point position = 2;
inline bool Element::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Element::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Element::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Element::clear_position() {
  if (position_ != NULL) position_->::framework::Point::Clear();
  clear_has_position();
}
inline const ::framework::Point& Element::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::framework::Point* Element::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::framework::Point;
  return position_;
}
inline ::framework::Point* Element::release_position() {
  clear_has_position();
  ::framework::Point* temp = position_;
  position_ = NULL;
  return temp;
}

// required .framework.Rect boundingBox = 3;
inline bool Element::has_boundingbox() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Element::set_has_boundingbox() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Element::clear_has_boundingbox() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Element::clear_boundingbox() {
  if (boundingbox_ != NULL) boundingbox_->::framework::Rect::Clear();
  clear_has_boundingbox();
}
inline const ::framework::Rect& Element::boundingbox() const {
  return boundingbox_ != NULL ? *boundingbox_ : *default_instance_->boundingbox_;
}
inline ::framework::Rect* Element::mutable_boundingbox() {
  set_has_boundingbox();
  if (boundingbox_ == NULL) boundingbox_ = new ::framework::Rect;
  return boundingbox_;
}
inline ::framework::Rect* Element::release_boundingbox() {
  clear_has_boundingbox();
  ::framework::Rect* temp = boundingbox_;
  boundingbox_ = NULL;
  return temp;
}

// optional string libName = 4;
inline bool Element::has_libname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Element::set_has_libname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Element::clear_has_libname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Element::clear_libname() {
  if (libname_ != &::google::protobuf::internal::kEmptyString) {
    libname_->clear();
  }
  clear_has_libname();
}
inline const ::std::string& Element::libname() const {
  return *libname_;
}
inline void Element::set_libname(const ::std::string& value) {
  set_has_libname();
  if (libname_ == &::google::protobuf::internal::kEmptyString) {
    libname_ = new ::std::string;
  }
  libname_->assign(value);
}
inline void Element::set_libname(const char* value) {
  set_has_libname();
  if (libname_ == &::google::protobuf::internal::kEmptyString) {
    libname_ = new ::std::string;
  }
  libname_->assign(value);
}
inline void Element::set_libname(const char* value, size_t size) {
  set_has_libname();
  if (libname_ == &::google::protobuf::internal::kEmptyString) {
    libname_ = new ::std::string;
  }
  libname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Element::mutable_libname() {
  set_has_libname();
  if (libname_ == &::google::protobuf::internal::kEmptyString) {
    libname_ = new ::std::string;
  }
  return libname_;
}
inline ::std::string* Element::release_libname() {
  clear_has_libname();
  if (libname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = libname_;
    libname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instanceName = 5;
inline bool Element::has_instancename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Element::set_has_instancename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Element::clear_has_instancename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Element::clear_instancename() {
  if (instancename_ != &::google::protobuf::internal::kEmptyString) {
    instancename_->clear();
  }
  clear_has_instancename();
}
inline const ::std::string& Element::instancename() const {
  return *instancename_;
}
inline void Element::set_instancename(const ::std::string& value) {
  set_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    instancename_ = new ::std::string;
  }
  instancename_->assign(value);
}
inline void Element::set_instancename(const char* value) {
  set_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    instancename_ = new ::std::string;
  }
  instancename_->assign(value);
}
inline void Element::set_instancename(const char* value, size_t size) {
  set_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    instancename_ = new ::std::string;
  }
  instancename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Element::mutable_instancename() {
  set_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    instancename_ = new ::std::string;
  }
  return instancename_;
}
inline ::std::string* Element::release_instancename() {
  clear_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instancename_;
    instancename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float rotation = 6;
inline bool Element::has_rotation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Element::set_has_rotation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Element::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Element::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float Element::rotation() const {
  return rotation_;
}
inline void Element::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .framework.Point anchorPoint = 7;
inline bool Element::has_anchorpoint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Element::set_has_anchorpoint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Element::clear_has_anchorpoint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Element::clear_anchorpoint() {
  if (anchorpoint_ != NULL) anchorpoint_->::framework::Point::Clear();
  clear_has_anchorpoint();
}
inline const ::framework::Point& Element::anchorpoint() const {
  return anchorpoint_ != NULL ? *anchorpoint_ : *default_instance_->anchorpoint_;
}
inline ::framework::Point* Element::mutable_anchorpoint() {
  set_has_anchorpoint();
  if (anchorpoint_ == NULL) anchorpoint_ = new ::framework::Point;
  return anchorpoint_;
}
inline ::framework::Point* Element::release_anchorpoint() {
  clear_has_anchorpoint();
  ::framework::Point* temp = anchorpoint_;
  anchorpoint_ = NULL;
  return temp;
}

// optional .framework.Point scaleValue = 8;
inline bool Element::has_scalevalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Element::set_has_scalevalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Element::clear_has_scalevalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Element::clear_scalevalue() {
  if (scalevalue_ != NULL) scalevalue_->::framework::Point::Clear();
  clear_has_scalevalue();
}
inline const ::framework::Point& Element::scalevalue() const {
  return scalevalue_ != NULL ? *scalevalue_ : *default_instance_->scalevalue_;
}
inline ::framework::Point* Element::mutable_scalevalue() {
  set_has_scalevalue();
  if (scalevalue_ == NULL) scalevalue_ = new ::framework::Point;
  return scalevalue_;
}
inline ::framework::Point* Element::release_scalevalue() {
  clear_has_scalevalue();
  ::framework::Point* temp = scalevalue_;
  scalevalue_ = NULL;
  return temp;
}

// optional int32 alpha = 9 [default = 255];
inline bool Element::has_alpha() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Element::set_has_alpha() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Element::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Element::clear_alpha() {
  alpha_ = 255;
  clear_has_alpha();
}
inline ::google::protobuf::int32 Element::alpha() const {
  return alpha_;
}
inline void Element::set_alpha(::google::protobuf::int32 value) {
  set_has_alpha();
  alpha_ = value;
}

// optional .framework.Color color = 10;
inline bool Element::has_color() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Element::set_has_color() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Element::clear_has_color() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Element::clear_color() {
  if (color_ != NULL) color_->::framework::Color::Clear();
  clear_has_color();
}
inline const ::framework::Color& Element::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::framework::Color* Element::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::framework::Color;
  return color_;
}
inline ::framework::Color* Element::release_color() {
  clear_has_color();
  ::framework::Color* temp = color_;
  color_ = NULL;
  return temp;
}

// optional string text = 11;
inline bool Element::has_text() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Element::set_has_text() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Element::clear_has_text() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Element::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Element::text() const {
  return *text_;
}
inline void Element::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Element::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Element::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Element::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Element::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 fontSize = 12 [default = 12];
inline bool Element::has_fontsize() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Element::set_has_fontsize() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Element::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Element::clear_fontsize() {
  fontsize_ = 12;
  clear_has_fontsize();
}
inline ::google::protobuf::int32 Element::fontsize() const {
  return fontsize_;
}
inline void Element::set_fontsize(::google::protobuf::int32 value) {
  set_has_fontsize();
  fontsize_ = value;
}

// optional string fnt = 13;
inline bool Element::has_fnt() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Element::set_has_fnt() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Element::clear_has_fnt() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Element::clear_fnt() {
  if (fnt_ != &::google::protobuf::internal::kEmptyString) {
    fnt_->clear();
  }
  clear_has_fnt();
}
inline const ::std::string& Element::fnt() const {
  return *fnt_;
}
inline void Element::set_fnt(const ::std::string& value) {
  set_has_fnt();
  if (fnt_ == &::google::protobuf::internal::kEmptyString) {
    fnt_ = new ::std::string;
  }
  fnt_->assign(value);
}
inline void Element::set_fnt(const char* value) {
  set_has_fnt();
  if (fnt_ == &::google::protobuf::internal::kEmptyString) {
    fnt_ = new ::std::string;
  }
  fnt_->assign(value);
}
inline void Element::set_fnt(const char* value, size_t size) {
  set_has_fnt();
  if (fnt_ == &::google::protobuf::internal::kEmptyString) {
    fnt_ = new ::std::string;
  }
  fnt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Element::mutable_fnt() {
  set_has_fnt();
  if (fnt_ == &::google::protobuf::internal::kEmptyString) {
    fnt_ = new ::std::string;
  }
  return fnt_;
}
inline ::std::string* Element::release_fnt() {
  clear_has_fnt();
  if (fnt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fnt_;
    fnt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 alignment = 14;
inline bool Element::has_alignment() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Element::set_has_alignment() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Element::clear_has_alignment() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Element::clear_alignment() {
  alignment_ = 0;
  clear_has_alignment();
}
inline ::google::protobuf::int32 Element::alignment() const {
  return alignment_;
}
inline void Element::set_alignment(::google::protobuf::int32 value) {
  set_has_alignment();
  alignment_ = value;
}

// optional .framework.Point skew = 15;
inline bool Element::has_skew() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Element::set_has_skew() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Element::clear_has_skew() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Element::clear_skew() {
  if (skew_ != NULL) skew_->::framework::Point::Clear();
  clear_has_skew();
}
inline const ::framework::Point& Element::skew() const {
  return skew_ != NULL ? *skew_ : *default_instance_->skew_;
}
inline ::framework::Point* Element::mutable_skew() {
  set_has_skew();
  if (skew_ == NULL) skew_ = new ::framework::Point;
  return skew_;
}
inline ::framework::Point* Element::release_skew() {
  clear_has_skew();
  ::framework::Point* temp = skew_;
  skew_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Keyframe

// required int32 startFrame = 1;
inline bool Keyframe::has_startframe() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Keyframe::set_has_startframe() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Keyframe::clear_has_startframe() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Keyframe::clear_startframe() {
  startframe_ = 0;
  clear_has_startframe();
}
inline ::google::protobuf::int32 Keyframe::startframe() const {
  return startframe_;
}
inline void Keyframe::set_startframe(::google::protobuf::int32 value) {
  set_has_startframe();
  startframe_ = value;
}

// optional bool isMotion = 5 [default = false];
inline bool Keyframe::has_ismotion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Keyframe::set_has_ismotion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Keyframe::clear_has_ismotion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Keyframe::clear_ismotion() {
  ismotion_ = false;
  clear_has_ismotion();
}
inline bool Keyframe::ismotion() const {
  return ismotion_;
}
inline void Keyframe::set_ismotion(bool value) {
  set_has_ismotion();
  ismotion_ = value;
}

// repeated .framework.Element elements = 3;
inline int Keyframe::elements_size() const {
  return elements_.size();
}
inline void Keyframe::clear_elements() {
  elements_.Clear();
}
inline const ::framework::Element& Keyframe::elements(int index) const {
  return elements_.Get(index);
}
inline ::framework::Element* Keyframe::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::framework::Element* Keyframe::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::framework::Element >&
Keyframe::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::framework::Element >*
Keyframe::mutable_elements() {
  return &elements_;
}

// optional int32 duration = 4 [default = 1];
inline bool Keyframe::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Keyframe::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Keyframe::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Keyframe::clear_duration() {
  duration_ = 1;
  clear_has_duration();
}
inline ::google::protobuf::int32 Keyframe::duration() const {
  return duration_;
}
inline void Keyframe::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional string script = 6;
inline bool Keyframe::has_script() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Keyframe::set_has_script() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Keyframe::clear_has_script() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Keyframe::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& Keyframe::script() const {
  return *script_;
}
inline void Keyframe::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void Keyframe::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void Keyframe::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Keyframe::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* Keyframe::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Layer

// repeated .framework.Keyframe keyframes = 1;
inline int Layer::keyframes_size() const {
  return keyframes_.size();
}
inline void Layer::clear_keyframes() {
  keyframes_.Clear();
}
inline const ::framework::Keyframe& Layer::keyframes(int index) const {
  return keyframes_.Get(index);
}
inline ::framework::Keyframe* Layer::mutable_keyframes(int index) {
  return keyframes_.Mutable(index);
}
inline ::framework::Keyframe* Layer::add_keyframes() {
  return keyframes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::framework::Keyframe >&
Layer::keyframes() const {
  return keyframes_;
}
inline ::google::protobuf::RepeatedPtrField< ::framework::Keyframe >*
Layer::mutable_keyframes() {
  return &keyframes_;
}

// optional string name = 2;
inline bool Layer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Layer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Layer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Layer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Layer::name() const {
  return *name_;
}
inline void Layer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Layer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Layer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Layer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AnimationKeyframe

// required int32 startFrame = 1;
inline bool AnimationKeyframe::has_startframe() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimationKeyframe::set_has_startframe() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimationKeyframe::clear_has_startframe() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimationKeyframe::clear_startframe() {
  startframe_ = 0;
  clear_has_startframe();
}
inline ::google::protobuf::int32 AnimationKeyframe::startframe() const {
  return startframe_;
}
inline void AnimationKeyframe::set_startframe(::google::protobuf::int32 value) {
  set_has_startframe();
  startframe_ = value;
}

// optional bool isMotion = 2 [default = false];
inline bool AnimationKeyframe::has_ismotion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnimationKeyframe::set_has_ismotion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnimationKeyframe::clear_has_ismotion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnimationKeyframe::clear_ismotion() {
  ismotion_ = false;
  clear_has_ismotion();
}
inline bool AnimationKeyframe::ismotion() const {
  return ismotion_;
}
inline void AnimationKeyframe::set_ismotion(bool value) {
  set_has_ismotion();
  ismotion_ = value;
}

// required .framework.Point position = 3;
inline bool AnimationKeyframe::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnimationKeyframe::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnimationKeyframe::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnimationKeyframe::clear_position() {
  if (position_ != NULL) position_->::framework::Point::Clear();
  clear_has_position();
}
inline const ::framework::Point& AnimationKeyframe::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::framework::Point* AnimationKeyframe::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::framework::Point;
  return position_;
}
inline ::framework::Point* AnimationKeyframe::release_position() {
  clear_has_position();
  ::framework::Point* temp = position_;
  position_ = NULL;
  return temp;
}

// optional int32 duration = 4 [default = 1];
inline bool AnimationKeyframe::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnimationKeyframe::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnimationKeyframe::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnimationKeyframe::clear_duration() {
  duration_ = 1;
  clear_has_duration();
}
inline ::google::protobuf::int32 AnimationKeyframe::duration() const {
  return duration_;
}
inline void AnimationKeyframe::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional string script = 5;
inline bool AnimationKeyframe::has_script() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnimationKeyframe::set_has_script() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnimationKeyframe::clear_has_script() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnimationKeyframe::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& AnimationKeyframe::script() const {
  return *script_;
}
inline void AnimationKeyframe::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AnimationKeyframe::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AnimationKeyframe::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimationKeyframe::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* AnimationKeyframe::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Animation

// repeated .framework.AnimationKeyframe keyframes = 1;
inline int Animation::keyframes_size() const {
  return keyframes_.size();
}
inline void Animation::clear_keyframes() {
  keyframes_.Clear();
}
inline const ::framework::AnimationKeyframe& Animation::keyframes(int index) const {
  return keyframes_.Get(index);
}
inline ::framework::AnimationKeyframe* Animation::mutable_keyframes(int index) {
  return keyframes_.Mutable(index);
}
inline ::framework::AnimationKeyframe* Animation::add_keyframes() {
  return keyframes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::framework::AnimationKeyframe >&
Animation::keyframes() const {
  return keyframes_;
}
inline ::google::protobuf::RepeatedPtrField< ::framework::AnimationKeyframe >*
Animation::mutable_keyframes() {
  return &keyframes_;
}

// -------------------------------------------------------------------

// Symbol

// required string name = 1;
inline bool Symbol::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Symbol::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Symbol::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Symbol::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Symbol::name() const {
  return *name_;
}
inline void Symbol::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Symbol::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Symbol::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Symbol::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Symbol::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .framework.Rect boundingBox = 2;
inline bool Symbol::has_boundingbox() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Symbol::set_has_boundingbox() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Symbol::clear_has_boundingbox() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Symbol::clear_boundingbox() {
  if (boundingbox_ != NULL) boundingbox_->::framework::Rect::Clear();
  clear_has_boundingbox();
}
inline const ::framework::Rect& Symbol::boundingbox() const {
  return boundingbox_ != NULL ? *boundingbox_ : *default_instance_->boundingbox_;
}
inline ::framework::Rect* Symbol::mutable_boundingbox() {
  set_has_boundingbox();
  if (boundingbox_ == NULL) boundingbox_ = new ::framework::Rect;
  return boundingbox_;
}
inline ::framework::Rect* Symbol::release_boundingbox() {
  clear_has_boundingbox();
  ::framework::Rect* temp = boundingbox_;
  boundingbox_ = NULL;
  return temp;
}

// required int32 frameCount = 3;
inline bool Symbol::has_framecount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Symbol::set_has_framecount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Symbol::clear_has_framecount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Symbol::clear_framecount() {
  framecount_ = 0;
  clear_has_framecount();
}
inline ::google::protobuf::int32 Symbol::framecount() const {
  return framecount_;
}
inline void Symbol::set_framecount(::google::protobuf::int32 value) {
  set_has_framecount();
  framecount_ = value;
}

// repeated .framework.Layer layers = 5;
inline int Symbol::layers_size() const {
  return layers_.size();
}
inline void Symbol::clear_layers() {
  layers_.Clear();
}
inline const ::framework::Layer& Symbol::layers(int index) const {
  return layers_.Get(index);
}
inline ::framework::Layer* Symbol::mutable_layers(int index) {
  return layers_.Mutable(index);
}
inline ::framework::Layer* Symbol::add_layers() {
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::framework::Layer >&
Symbol::layers() const {
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::framework::Layer >*
Symbol::mutable_layers() {
  return &layers_;
}

// repeated .framework.Animation anis = 9;
inline int Symbol::anis_size() const {
  return anis_.size();
}
inline void Symbol::clear_anis() {
  anis_.Clear();
}
inline const ::framework::Animation& Symbol::anis(int index) const {
  return anis_.Get(index);
}
inline ::framework::Animation* Symbol::mutable_anis(int index) {
  return anis_.Mutable(index);
}
inline ::framework::Animation* Symbol::add_anis() {
  return anis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::framework::Animation >&
Symbol::anis() const {
  return anis_;
}
inline ::google::protobuf::RepeatedPtrField< ::framework::Animation >*
Symbol::mutable_anis() {
  return &anis_;
}

// optional int32 frameRate = 10;
inline bool Symbol::has_framerate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Symbol::set_has_framerate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Symbol::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Symbol::clear_framerate() {
  framerate_ = 0;
  clear_has_framerate();
}
inline ::google::protobuf::int32 Symbol::framerate() const {
  return framerate_;
}
inline void Symbol::set_framerate(::google::protobuf::int32 value) {
  set_has_framerate();
  framerate_ = value;
}

// optional float pauseTime = 11;
inline bool Symbol::has_pausetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Symbol::set_has_pausetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Symbol::clear_has_pausetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Symbol::clear_pausetime() {
  pausetime_ = 0;
  clear_has_pausetime();
}
inline float Symbol::pausetime() const {
  return pausetime_;
}
inline void Symbol::set_pausetime(float value) {
  set_has_pausetime();
  pausetime_ = value;
}

// -------------------------------------------------------------------

// Anim

// repeated .framework.Symbol symbols = 1;
inline int Anim::symbols_size() const {
  return symbols_.size();
}
inline void Anim::clear_symbols() {
  symbols_.Clear();
}
inline const ::framework::Symbol& Anim::symbols(int index) const {
  return symbols_.Get(index);
}
inline ::framework::Symbol* Anim::mutable_symbols(int index) {
  return symbols_.Mutable(index);
}
inline ::framework::Symbol* Anim::add_symbols() {
  return symbols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::framework::Symbol >&
Anim::symbols() const {
  return symbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::framework::Symbol >*
Anim::mutable_symbols() {
  return &symbols_;
}

// -------------------------------------------------------------------

// AnimIndexItem

// required string name = 1;
inline bool AnimIndexItem::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimIndexItem::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimIndexItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimIndexItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AnimIndexItem::name() const {
  return *name_;
}
inline void AnimIndexItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AnimIndexItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AnimIndexItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimIndexItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AnimIndexItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string symbols = 2;
inline int AnimIndexItem::symbols_size() const {
  return symbols_.size();
}
inline void AnimIndexItem::clear_symbols() {
  symbols_.Clear();
}
inline const ::std::string& AnimIndexItem::symbols(int index) const {
  return symbols_.Get(index);
}
inline ::std::string* AnimIndexItem::mutable_symbols(int index) {
  return symbols_.Mutable(index);
}
inline void AnimIndexItem::set_symbols(int index, const ::std::string& value) {
  symbols_.Mutable(index)->assign(value);
}
inline void AnimIndexItem::set_symbols(int index, const char* value) {
  symbols_.Mutable(index)->assign(value);
}
inline void AnimIndexItem::set_symbols(int index, const char* value, size_t size) {
  symbols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimIndexItem::add_symbols() {
  return symbols_.Add();
}
inline void AnimIndexItem::add_symbols(const ::std::string& value) {
  symbols_.Add()->assign(value);
}
inline void AnimIndexItem::add_symbols(const char* value) {
  symbols_.Add()->assign(value);
}
inline void AnimIndexItem::add_symbols(const char* value, size_t size) {
  symbols_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AnimIndexItem::symbols() const {
  return symbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AnimIndexItem::mutable_symbols() {
  return &symbols_;
}

// -------------------------------------------------------------------

// AnimIndex

// repeated .framework.AnimIndexItem anims = 1;
inline int AnimIndex::anims_size() const {
  return anims_.size();
}
inline void AnimIndex::clear_anims() {
  anims_.Clear();
}
inline const ::framework::AnimIndexItem& AnimIndex::anims(int index) const {
  return anims_.Get(index);
}
inline ::framework::AnimIndexItem* AnimIndex::mutable_anims(int index) {
  return anims_.Mutable(index);
}
inline ::framework::AnimIndexItem* AnimIndex::add_anims() {
  return anims_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::framework::AnimIndexItem >&
AnimIndex::anims() const {
  return anims_;
}
inline ::google::protobuf::RepeatedPtrField< ::framework::AnimIndexItem >*
AnimIndex::mutable_anims() {
  return &anims_;
}

// -------------------------------------------------------------------

// Frame

// required string name = 1;
inline bool Frame::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Frame::name() const {
  return *name_;
}
inline void Frame::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Frame::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Frame::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Frame::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Frame::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 x = 2;
inline bool Frame::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Frame::x() const {
  return x_;
}
inline void Frame::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 3;
inline bool Frame::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Frame::y() const {
  return y_;
}
inline void Frame::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 w = 4;
inline bool Frame::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Frame::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Frame::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Frame::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 Frame::w() const {
  return w_;
}
inline void Frame::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
}

// required int32 h = 5;
inline bool Frame::has_h() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Frame::set_has_h() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Frame::clear_has_h() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Frame::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 Frame::h() const {
  return h_;
}
inline void Frame::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
}

// required bool rotated = 6;
inline bool Frame::has_rotated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Frame::set_has_rotated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Frame::clear_has_rotated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Frame::clear_rotated() {
  rotated_ = false;
  clear_has_rotated();
}
inline bool Frame::rotated() const {
  return rotated_;
}
inline void Frame::set_rotated(bool value) {
  set_has_rotated();
  rotated_ = value;
}

// required int32 filename = 7;
inline bool Frame::has_filename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Frame::set_has_filename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Frame::clear_has_filename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Frame::clear_filename() {
  filename_ = 0;
  clear_has_filename();
}
inline ::google::protobuf::int32 Frame::filename() const {
  return filename_;
}
inline void Frame::set_filename(::google::protobuf::int32 value) {
  set_has_filename();
  filename_ = value;
}

// -------------------------------------------------------------------

// FrameList

// repeated .framework.Frame frames = 1;
inline int FrameList::frames_size() const {
  return frames_.size();
}
inline void FrameList::clear_frames() {
  frames_.Clear();
}
inline const ::framework::Frame& FrameList::frames(int index) const {
  return frames_.Get(index);
}
inline ::framework::Frame* FrameList::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::framework::Frame* FrameList::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::framework::Frame >&
FrameList::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::framework::Frame >*
FrameList::mutable_frames() {
  return &frames_;
}

// repeated string filenames = 2;
inline int FrameList::filenames_size() const {
  return filenames_.size();
}
inline void FrameList::clear_filenames() {
  filenames_.Clear();
}
inline const ::std::string& FrameList::filenames(int index) const {
  return filenames_.Get(index);
}
inline ::std::string* FrameList::mutable_filenames(int index) {
  return filenames_.Mutable(index);
}
inline void FrameList::set_filenames(int index, const ::std::string& value) {
  filenames_.Mutable(index)->assign(value);
}
inline void FrameList::set_filenames(int index, const char* value) {
  filenames_.Mutable(index)->assign(value);
}
inline void FrameList::set_filenames(int index, const char* value, size_t size) {
  filenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameList::add_filenames() {
  return filenames_.Add();
}
inline void FrameList::add_filenames(const ::std::string& value) {
  filenames_.Add()->assign(value);
}
inline void FrameList::add_filenames(const char* value) {
  filenames_.Add()->assign(value);
}
inline void FrameList::add_filenames(const char* value, size_t size) {
  filenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FrameList::filenames() const {
  return filenames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FrameList::mutable_filenames() {
  return &filenames_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace framework

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_anim_2eproto__INCLUDED
