// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "anim.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace framework {

void protobuf_ShutdownFile_anim_2eproto() {
  delete Rect::default_instance_;
  delete Point::default_instance_;
  delete Color::default_instance_;
  delete Element::default_instance_;
  delete Keyframe::default_instance_;
  delete Layer::default_instance_;
  delete AnimationKeyframe::default_instance_;
  delete Animation::default_instance_;
  delete Symbol::default_instance_;
  delete Anim::default_instance_;
  delete AnimIndexItem::default_instance_;
  delete AnimIndex::default_instance_;
  delete Frame::default_instance_;
  delete FrameList::default_instance_;
}

void protobuf_AddDesc_anim_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  Rect::default_instance_ = new Rect();
  Point::default_instance_ = new Point();
  Color::default_instance_ = new Color();
  Element::default_instance_ = new Element();
  Keyframe::default_instance_ = new Keyframe();
  Layer::default_instance_ = new Layer();
  AnimationKeyframe::default_instance_ = new AnimationKeyframe();
  Animation::default_instance_ = new Animation();
  Symbol::default_instance_ = new Symbol();
  Anim::default_instance_ = new Anim();
  AnimIndexItem::default_instance_ = new AnimIndexItem();
  AnimIndex::default_instance_ = new AnimIndex();
  Frame::default_instance_ = new Frame();
  FrameList::default_instance_ = new FrameList();
  Rect::default_instance_->InitAsDefaultInstance();
  Point::default_instance_->InitAsDefaultInstance();
  Color::default_instance_->InitAsDefaultInstance();
  Element::default_instance_->InitAsDefaultInstance();
  Keyframe::default_instance_->InitAsDefaultInstance();
  Layer::default_instance_->InitAsDefaultInstance();
  AnimationKeyframe::default_instance_->InitAsDefaultInstance();
  Animation::default_instance_->InitAsDefaultInstance();
  Symbol::default_instance_->InitAsDefaultInstance();
  Anim::default_instance_->InitAsDefaultInstance();
  AnimIndexItem::default_instance_->InitAsDefaultInstance();
  AnimIndex::default_instance_->InitAsDefaultInstance();
  Frame::default_instance_->InitAsDefaultInstance();
  FrameList::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_anim_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_anim_2eproto {
  StaticDescriptorInitializer_anim_2eproto() {
    protobuf_AddDesc_anim_2eproto();
  }
} static_descriptor_initializer_anim_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Rect::kXFieldNumber;
const int Rect::kYFieldNumber;
const int Rect::kWFieldNumber;
const int Rect::kHFieldNumber;
#endif  // !_MSC_VER

Rect::Rect()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Rect::InitAsDefaultInstance() {
}

Rect::Rect(const Rect& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Rect::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  w_ = 0;
  h_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Rect::~Rect() {
  SharedDtor();
}

void Rect::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Rect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Rect& Rect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Rect* Rect::default_instance_ = NULL;

Rect* Rect::New() const {
  return new Rect;
}

void Rect::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    w_ = 0;
    h_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Rect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }
      
      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_w;
        break;
      }
      
      // required float w = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_h;
        break;
      }
      
      // required float h = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_h:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &h_)));
          set_has_h();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Rect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }
  
  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }
  
  // required float w = 3;
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->w(), output);
  }
  
  // required float h = 4;
  if (has_h()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->h(), output);
  }
  
}

int Rect::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }
    
    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }
    
    // required float w = 3;
    if (has_w()) {
      total_size += 1 + 4;
    }
    
    // required float h = 4;
    if (has_h()) {
      total_size += 1 + 4;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Rect::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Rect*>(&from));
}

void Rect::MergeFrom(const Rect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
    if (from.has_h()) {
      set_h(from.h());
    }
  }
}

void Rect::CopyFrom(const Rect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void Rect::Swap(Rect* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(w_, other->w_);
    std::swap(h_, other->h_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Rect::GetTypeName() const {
  return "framework.Rect";
}


// ===================================================================

#ifndef _MSC_VER
const int Point::kXFieldNumber;
const int Point::kYFieldNumber;
#endif  // !_MSC_VER

Point::Point()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Point::InitAsDefaultInstance() {
}

Point::Point(const Point& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Point::~Point() {
  SharedDtor();
}

void Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Point& Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Point* Point::default_instance_ = NULL;

Point* Point::New() const {
  return new Point;
}

void Point::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }
      
      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }
  
  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }
  
}

int Point::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }
    
    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Point*>(&from));
}

void Point::MergeFrom(const Point& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void Point::CopyFrom(const Point& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Point::Swap(Point* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Point::GetTypeName() const {
  return "framework.Point";
}


// ===================================================================

#ifndef _MSC_VER
const int Color::kRFieldNumber;
const int Color::kGFieldNumber;
const int Color::kBFieldNumber;
#endif  // !_MSC_VER

Color::Color()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Color::InitAsDefaultInstance() {
}

Color::Color(const Color& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Color::SharedCtor() {
  _cached_size_ = 0;
  r_ = 0;
  g_ = 0;
  b_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Color::~Color() {
  SharedDtor();
}

void Color::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Color::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Color& Color::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Color* Color::default_instance_ = NULL;

Color* Color::New() const {
  return new Color;
}

void Color::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    r_ = 0;
    g_ = 0;
    b_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Color::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 r = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &r_)));
          set_has_r();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_g;
        break;
      }
      
      // required int32 g = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_g:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &g_)));
          set_has_g();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_b;
        break;
      }
      
      // required int32 b = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_b:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &b_)));
          set_has_b();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Color::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 r = 1;
  if (has_r()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->r(), output);
  }
  
  // required int32 g = 2;
  if (has_g()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->g(), output);
  }
  
  // required int32 b = 3;
  if (has_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->b(), output);
  }
  
}

int Color::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 r = 1;
    if (has_r()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->r());
    }
    
    // required int32 g = 2;
    if (has_g()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->g());
    }
    
    // required int32 b = 3;
    if (has_b()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->b());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Color::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Color*>(&from));
}

void Color::MergeFrom(const Color& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_r()) {
      set_r(from.r());
    }
    if (from.has_g()) {
      set_g(from.g());
    }
    if (from.has_b()) {
      set_b(from.b());
    }
  }
}

void Color::CopyFrom(const Color& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Color::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Color::Swap(Color* other) {
  if (other != this) {
    std::swap(r_, other->r_);
    std::swap(g_, other->g_);
    std::swap(b_, other->b_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Color::GetTypeName() const {
  return "framework.Color";
}


// ===================================================================

bool Element_ElementType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 4:
    case 7:
    case 8:
    case 9:
    case 11:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Element_ElementType Element::ND_MOVIECLIP;
const Element_ElementType Element::ND_BITMAP;
const Element_ElementType Element::ND_TTFTEXT;
const Element_ElementType Element::ND_FRAME;
const Element_ElementType Element::ND_RECT;
const Element_ElementType Element::ND_BMTEXT;
const Element_ElementType Element::ND_PARTICLE;
const Element_ElementType Element::ElementType_MIN;
const Element_ElementType Element::ElementType_MAX;
const int Element::ElementType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Element::kTypeFieldNumber;
const int Element::kPositionFieldNumber;
const int Element::kBoundingBoxFieldNumber;
const int Element::kLibNameFieldNumber;
const int Element::kInstanceNameFieldNumber;
const int Element::kRotationFieldNumber;
const int Element::kAnchorPointFieldNumber;
const int Element::kScaleValueFieldNumber;
const int Element::kAlphaFieldNumber;
const int Element::kColorFieldNumber;
const int Element::kTextFieldNumber;
const int Element::kFontSizeFieldNumber;
const int Element::kFntFieldNumber;
const int Element::kAlignmentFieldNumber;
const int Element::kSkewFieldNumber;
#endif  // !_MSC_VER

Element::Element()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Element::InitAsDefaultInstance() {
  position_ = const_cast< ::framework::Point*>(&::framework::Point::default_instance());
  boundingbox_ = const_cast< ::framework::Rect*>(&::framework::Rect::default_instance());
  anchorpoint_ = const_cast< ::framework::Point*>(&::framework::Point::default_instance());
  scalevalue_ = const_cast< ::framework::Point*>(&::framework::Point::default_instance());
  color_ = const_cast< ::framework::Color*>(&::framework::Color::default_instance());
  skew_ = const_cast< ::framework::Point*>(&::framework::Point::default_instance());
}

Element::Element(const Element& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Element::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  position_ = NULL;
  boundingbox_ = NULL;
  libname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  instancename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  rotation_ = 0;
  anchorpoint_ = NULL;
  scalevalue_ = NULL;
  alpha_ = 255;
  color_ = NULL;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fontsize_ = 12;
  fnt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  alignment_ = 0;
  skew_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Element::~Element() {
  SharedDtor();
}

void Element::SharedDtor() {
  if (libname_ != &::google::protobuf::internal::kEmptyString) {
    delete libname_;
  }
  if (instancename_ != &::google::protobuf::internal::kEmptyString) {
    delete instancename_;
  }
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (fnt_ != &::google::protobuf::internal::kEmptyString) {
    delete fnt_;
  }
  if (this != default_instance_) {
    delete position_;
    delete boundingbox_;
    delete anchorpoint_;
    delete scalevalue_;
    delete color_;
    delete skew_;
  }
}

void Element::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Element& Element::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Element* Element::default_instance_ = NULL;

Element* Element::New() const {
  return new Element;
}

void Element::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_position()) {
      if (position_ != NULL) position_->::framework::Point::Clear();
    }
    if (has_boundingbox()) {
      if (boundingbox_ != NULL) boundingbox_->::framework::Rect::Clear();
    }
    if (has_libname()) {
      if (libname_ != &::google::protobuf::internal::kEmptyString) {
        libname_->clear();
      }
    }
    if (has_instancename()) {
      if (instancename_ != &::google::protobuf::internal::kEmptyString) {
        instancename_->clear();
      }
    }
    rotation_ = 0;
    if (has_anchorpoint()) {
      if (anchorpoint_ != NULL) anchorpoint_->::framework::Point::Clear();
    }
    if (has_scalevalue()) {
      if (scalevalue_ != NULL) scalevalue_->::framework::Point::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    alpha_ = 255;
    if (has_color()) {
      if (color_ != NULL) color_->::framework::Color::Clear();
    }
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
    fontsize_ = 12;
    if (has_fnt()) {
      if (fnt_ != &::google::protobuf::internal::kEmptyString) {
        fnt_->clear();
      }
    }
    alignment_ = 0;
    if (has_skew()) {
      if (skew_ != NULL) skew_->::framework::Point::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Element::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .framework.Element.ElementType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::framework::Element_ElementType_IsValid(value)) {
            set_type(static_cast< ::framework::Element_ElementType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_position;
        break;
      }
      
      // required .framework.Point position = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_boundingBox;
        break;
      }
      
      // required .framework.Rect boundingBox = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_boundingBox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_boundingbox()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_libName;
        break;
      }
      
      // optional string libName = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_libName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_libname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_instanceName;
        break;
      }
      
      // optional string instanceName = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_instanceName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_instancename()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_rotation;
        break;
      }
      
      // optional float rotation = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotation_)));
          set_has_rotation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_anchorPoint;
        break;
      }
      
      // optional .framework.Point anchorPoint = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_anchorPoint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anchorpoint()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_scaleValue;
        break;
      }
      
      // optional .framework.Point scaleValue = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_scaleValue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scalevalue()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_alpha;
        break;
      }
      
      // optional int32 alpha = 9 [default = 255];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alpha:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alpha_)));
          set_has_alpha();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_color;
        break;
      }
      
      // optional .framework.Color color = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_text;
        break;
      }
      
      // optional string text = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_fontSize;
        break;
      }
      
      // optional int32 fontSize = 12 [default = 12];
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fontSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fontsize_)));
          set_has_fontsize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_fnt;
        break;
      }
      
      // optional string fnt = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fnt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fnt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_alignment;
        break;
      }
      
      // optional int32 alignment = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alignment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alignment_)));
          set_has_alignment();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_skew;
        break;
      }
      
      // optional .framework.Point skew = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_skew:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_skew()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Element::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .framework.Element.ElementType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // required .framework.Point position = 2;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->position(), output);
  }
  
  // required .framework.Rect boundingBox = 3;
  if (has_boundingbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->boundingbox(), output);
  }
  
  // optional string libName = 4;
  if (has_libname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->libname(), output);
  }
  
  // optional string instanceName = 5;
  if (has_instancename()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->instancename(), output);
  }
  
  // optional float rotation = 6;
  if (has_rotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->rotation(), output);
  }
  
  // optional .framework.Point anchorPoint = 7;
  if (has_anchorpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->anchorpoint(), output);
  }
  
  // optional .framework.Point scaleValue = 8;
  if (has_scalevalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->scalevalue(), output);
  }
  
  // optional int32 alpha = 9 [default = 255];
  if (has_alpha()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->alpha(), output);
  }
  
  // optional .framework.Color color = 10;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->color(), output);
  }
  
  // optional string text = 11;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->text(), output);
  }
  
  // optional int32 fontSize = 12 [default = 12];
  if (has_fontsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->fontsize(), output);
  }
  
  // optional string fnt = 13;
  if (has_fnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->fnt(), output);
  }
  
  // optional int32 alignment = 14;
  if (has_alignment()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->alignment(), output);
  }
  
  // optional .framework.Point skew = 15;
  if (has_skew()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->skew(), output);
  }
  
}

int Element::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .framework.Element.ElementType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // required .framework.Point position = 2;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }
    
    // required .framework.Rect boundingBox = 3;
    if (has_boundingbox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->boundingbox());
    }
    
    // optional string libName = 4;
    if (has_libname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->libname());
    }
    
    // optional string instanceName = 5;
    if (has_instancename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->instancename());
    }
    
    // optional float rotation = 6;
    if (has_rotation()) {
      total_size += 1 + 4;
    }
    
    // optional .framework.Point anchorPoint = 7;
    if (has_anchorpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anchorpoint());
    }
    
    // optional .framework.Point scaleValue = 8;
    if (has_scalevalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scalevalue());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 alpha = 9 [default = 255];
    if (has_alpha()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alpha());
    }
    
    // optional .framework.Color color = 10;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->color());
    }
    
    // optional string text = 11;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
    // optional int32 fontSize = 12 [default = 12];
    if (has_fontsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fontsize());
    }
    
    // optional string fnt = 13;
    if (has_fnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fnt());
    }
    
    // optional int32 alignment = 14;
    if (has_alignment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alignment());
    }
    
    // optional .framework.Point skew = 15;
    if (has_skew()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->skew());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Element::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Element*>(&from));
}

void Element::MergeFrom(const Element& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_position()) {
      mutable_position()->::framework::Point::MergeFrom(from.position());
    }
    if (from.has_boundingbox()) {
      mutable_boundingbox()->::framework::Rect::MergeFrom(from.boundingbox());
    }
    if (from.has_libname()) {
      set_libname(from.libname());
    }
    if (from.has_instancename()) {
      set_instancename(from.instancename());
    }
    if (from.has_rotation()) {
      set_rotation(from.rotation());
    }
    if (from.has_anchorpoint()) {
      mutable_anchorpoint()->::framework::Point::MergeFrom(from.anchorpoint());
    }
    if (from.has_scalevalue()) {
      mutable_scalevalue()->::framework::Point::MergeFrom(from.scalevalue());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_alpha()) {
      set_alpha(from.alpha());
    }
    if (from.has_color()) {
      mutable_color()->::framework::Color::MergeFrom(from.color());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
    if (from.has_fontsize()) {
      set_fontsize(from.fontsize());
    }
    if (from.has_fnt()) {
      set_fnt(from.fnt());
    }
    if (from.has_alignment()) {
      set_alignment(from.alignment());
    }
    if (from.has_skew()) {
      mutable_skew()->::framework::Point::MergeFrom(from.skew());
    }
  }
}

void Element::CopyFrom(const Element& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Element::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  if (has_boundingbox()) {
    if (!this->boundingbox().IsInitialized()) return false;
  }
  if (has_anchorpoint()) {
    if (!this->anchorpoint().IsInitialized()) return false;
  }
  if (has_scalevalue()) {
    if (!this->scalevalue().IsInitialized()) return false;
  }
  if (has_color()) {
    if (!this->color().IsInitialized()) return false;
  }
  if (has_skew()) {
    if (!this->skew().IsInitialized()) return false;
  }
  return true;
}

void Element::Swap(Element* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(position_, other->position_);
    std::swap(boundingbox_, other->boundingbox_);
    std::swap(libname_, other->libname_);
    std::swap(instancename_, other->instancename_);
    std::swap(rotation_, other->rotation_);
    std::swap(anchorpoint_, other->anchorpoint_);
    std::swap(scalevalue_, other->scalevalue_);
    std::swap(alpha_, other->alpha_);
    std::swap(color_, other->color_);
    std::swap(text_, other->text_);
    std::swap(fontsize_, other->fontsize_);
    std::swap(fnt_, other->fnt_);
    std::swap(alignment_, other->alignment_);
    std::swap(skew_, other->skew_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Element::GetTypeName() const {
  return "framework.Element";
}


// ===================================================================

#ifndef _MSC_VER
const int Keyframe::kStartFrameFieldNumber;
const int Keyframe::kIsMotionFieldNumber;
const int Keyframe::kElementsFieldNumber;
const int Keyframe::kDurationFieldNumber;
const int Keyframe::kScriptFieldNumber;
#endif  // !_MSC_VER

Keyframe::Keyframe()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Keyframe::InitAsDefaultInstance() {
}

Keyframe::Keyframe(const Keyframe& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Keyframe::SharedCtor() {
  _cached_size_ = 0;
  startframe_ = 0;
  ismotion_ = false;
  duration_ = 1;
  script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Keyframe::~Keyframe() {
  SharedDtor();
}

void Keyframe::SharedDtor() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    delete script_;
  }
  if (this != default_instance_) {
  }
}

void Keyframe::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Keyframe& Keyframe::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Keyframe* Keyframe::default_instance_ = NULL;

Keyframe* Keyframe::New() const {
  return new Keyframe;
}

void Keyframe::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    startframe_ = 0;
    ismotion_ = false;
    duration_ = 1;
    if (has_script()) {
      if (script_ != &::google::protobuf::internal::kEmptyString) {
        script_->clear();
      }
    }
  }
  elements_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Keyframe::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 startFrame = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &startframe_)));
          set_has_startframe();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_elements;
        break;
      }
      
      // repeated .framework.Element elements = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_elements:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_elements()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_elements;
        if (input->ExpectTag(32)) goto parse_duration;
        break;
      }
      
      // optional int32 duration = 4 [default = 1];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_isMotion;
        break;
      }
      
      // optional bool isMotion = 5 [default = false];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isMotion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ismotion_)));
          set_has_ismotion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_script;
        break;
      }
      
      // optional string script = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_script:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_script()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Keyframe::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 startFrame = 1;
  if (has_startframe()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->startframe(), output);
  }
  
  // repeated .framework.Element elements = 3;
  for (int i = 0; i < this->elements_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->elements(i), output);
  }
  
  // optional int32 duration = 4 [default = 1];
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->duration(), output);
  }
  
  // optional bool isMotion = 5 [default = false];
  if (has_ismotion()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->ismotion(), output);
  }
  
  // optional string script = 6;
  if (has_script()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->script(), output);
  }
  
}

int Keyframe::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 startFrame = 1;
    if (has_startframe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->startframe());
    }
    
    // optional bool isMotion = 5 [default = false];
    if (has_ismotion()) {
      total_size += 1 + 1;
    }
    
    // optional int32 duration = 4 [default = 1];
    if (has_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->duration());
    }
    
    // optional string script = 6;
    if (has_script()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->script());
    }
    
  }
  // repeated .framework.Element elements = 3;
  total_size += 1 * this->elements_size();
  for (int i = 0; i < this->elements_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->elements(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Keyframe::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Keyframe*>(&from));
}

void Keyframe::MergeFrom(const Keyframe& from) {
  GOOGLE_CHECK_NE(&from, this);
  elements_.MergeFrom(from.elements_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_startframe()) {
      set_startframe(from.startframe());
    }
    if (from.has_ismotion()) {
      set_ismotion(from.ismotion());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_script()) {
      set_script(from.script());
    }
  }
}

void Keyframe::CopyFrom(const Keyframe& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Keyframe::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < elements_size(); i++) {
    if (!this->elements(i).IsInitialized()) return false;
  }
  return true;
}

void Keyframe::Swap(Keyframe* other) {
  if (other != this) {
    std::swap(startframe_, other->startframe_);
    std::swap(ismotion_, other->ismotion_);
    elements_.Swap(&other->elements_);
    std::swap(duration_, other->duration_);
    std::swap(script_, other->script_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Keyframe::GetTypeName() const {
  return "framework.Keyframe";
}


// ===================================================================

#ifndef _MSC_VER
const int Layer::kKeyframesFieldNumber;
const int Layer::kNameFieldNumber;
#endif  // !_MSC_VER

Layer::Layer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Layer::InitAsDefaultInstance() {
}

Layer::Layer(const Layer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Layer::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Layer::~Layer() {
  SharedDtor();
}

void Layer::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Layer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Layer& Layer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Layer* Layer::default_instance_ = NULL;

Layer* Layer::New() const {
  return new Layer;
}

void Layer::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  keyframes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Layer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .framework.Keyframe keyframes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keyframes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_keyframes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_keyframes;
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Layer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .framework.Keyframe keyframes = 1;
  for (int i = 0; i < this->keyframes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->keyframes(i), output);
  }
  
  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
}

int Layer::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  // repeated .framework.Keyframe keyframes = 1;
  total_size += 1 * this->keyframes_size();
  for (int i = 0; i < this->keyframes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keyframes(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Layer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Layer*>(&from));
}

void Layer::MergeFrom(const Layer& from) {
  GOOGLE_CHECK_NE(&from, this);
  keyframes_.MergeFrom(from.keyframes_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void Layer::CopyFrom(const Layer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Layer::IsInitialized() const {
  
  for (int i = 0; i < keyframes_size(); i++) {
    if (!this->keyframes(i).IsInitialized()) return false;
  }
  return true;
}

void Layer::Swap(Layer* other) {
  if (other != this) {
    keyframes_.Swap(&other->keyframes_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Layer::GetTypeName() const {
  return "framework.Layer";
}


// ===================================================================

#ifndef _MSC_VER
const int AnimationKeyframe::kStartFrameFieldNumber;
const int AnimationKeyframe::kIsMotionFieldNumber;
const int AnimationKeyframe::kPositionFieldNumber;
const int AnimationKeyframe::kDurationFieldNumber;
const int AnimationKeyframe::kScriptFieldNumber;
#endif  // !_MSC_VER

AnimationKeyframe::AnimationKeyframe()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AnimationKeyframe::InitAsDefaultInstance() {
  position_ = const_cast< ::framework::Point*>(&::framework::Point::default_instance());
}

AnimationKeyframe::AnimationKeyframe(const AnimationKeyframe& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AnimationKeyframe::SharedCtor() {
  _cached_size_ = 0;
  startframe_ = 0;
  ismotion_ = false;
  position_ = NULL;
  duration_ = 1;
  script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AnimationKeyframe::~AnimationKeyframe() {
  SharedDtor();
}

void AnimationKeyframe::SharedDtor() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    delete script_;
  }
  if (this != default_instance_) {
    delete position_;
  }
}

void AnimationKeyframe::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AnimationKeyframe& AnimationKeyframe::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

AnimationKeyframe* AnimationKeyframe::default_instance_ = NULL;

AnimationKeyframe* AnimationKeyframe::New() const {
  return new AnimationKeyframe;
}

void AnimationKeyframe::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    startframe_ = 0;
    ismotion_ = false;
    if (has_position()) {
      if (position_ != NULL) position_->::framework::Point::Clear();
    }
    duration_ = 1;
    if (has_script()) {
      if (script_ != &::google::protobuf::internal::kEmptyString) {
        script_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AnimationKeyframe::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 startFrame = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &startframe_)));
          set_has_startframe();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_isMotion;
        break;
      }
      
      // optional bool isMotion = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isMotion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ismotion_)));
          set_has_ismotion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_position;
        break;
      }
      
      // required .framework.Point position = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_duration;
        break;
      }
      
      // optional int32 duration = 4 [default = 1];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_script;
        break;
      }
      
      // optional string script = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_script:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_script()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AnimationKeyframe::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 startFrame = 1;
  if (has_startframe()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->startframe(), output);
  }
  
  // optional bool isMotion = 2 [default = false];
  if (has_ismotion()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->ismotion(), output);
  }
  
  // required .framework.Point position = 3;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->position(), output);
  }
  
  // optional int32 duration = 4 [default = 1];
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->duration(), output);
  }
  
  // optional string script = 5;
  if (has_script()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->script(), output);
  }
  
}

int AnimationKeyframe::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 startFrame = 1;
    if (has_startframe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->startframe());
    }
    
    // optional bool isMotion = 2 [default = false];
    if (has_ismotion()) {
      total_size += 1 + 1;
    }
    
    // required .framework.Point position = 3;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }
    
    // optional int32 duration = 4 [default = 1];
    if (has_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->duration());
    }
    
    // optional string script = 5;
    if (has_script()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->script());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AnimationKeyframe::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AnimationKeyframe*>(&from));
}

void AnimationKeyframe::MergeFrom(const AnimationKeyframe& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_startframe()) {
      set_startframe(from.startframe());
    }
    if (from.has_ismotion()) {
      set_ismotion(from.ismotion());
    }
    if (from.has_position()) {
      mutable_position()->::framework::Point::MergeFrom(from.position());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_script()) {
      set_script(from.script());
    }
  }
}

void AnimationKeyframe::CopyFrom(const AnimationKeyframe& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnimationKeyframe::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  
  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  return true;
}

void AnimationKeyframe::Swap(AnimationKeyframe* other) {
  if (other != this) {
    std::swap(startframe_, other->startframe_);
    std::swap(ismotion_, other->ismotion_);
    std::swap(position_, other->position_);
    std::swap(duration_, other->duration_);
    std::swap(script_, other->script_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AnimationKeyframe::GetTypeName() const {
  return "framework.AnimationKeyframe";
}


// ===================================================================

#ifndef _MSC_VER
const int Animation::kKeyframesFieldNumber;
#endif  // !_MSC_VER

Animation::Animation()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Animation::InitAsDefaultInstance() {
}

Animation::Animation(const Animation& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Animation::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Animation::~Animation() {
  SharedDtor();
}

void Animation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Animation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Animation& Animation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Animation* Animation::default_instance_ = NULL;

Animation* Animation::New() const {
  return new Animation;
}

void Animation::Clear() {
  keyframes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Animation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .framework.AnimationKeyframe keyframes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keyframes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_keyframes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_keyframes;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Animation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .framework.AnimationKeyframe keyframes = 1;
  for (int i = 0; i < this->keyframes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->keyframes(i), output);
  }
  
}

int Animation::ByteSize() const {
  int total_size = 0;
  
  // repeated .framework.AnimationKeyframe keyframes = 1;
  total_size += 1 * this->keyframes_size();
  for (int i = 0; i < this->keyframes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keyframes(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Animation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Animation*>(&from));
}

void Animation::MergeFrom(const Animation& from) {
  GOOGLE_CHECK_NE(&from, this);
  keyframes_.MergeFrom(from.keyframes_);
}

void Animation::CopyFrom(const Animation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Animation::IsInitialized() const {
  
  for (int i = 0; i < keyframes_size(); i++) {
    if (!this->keyframes(i).IsInitialized()) return false;
  }
  return true;
}

void Animation::Swap(Animation* other) {
  if (other != this) {
    keyframes_.Swap(&other->keyframes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Animation::GetTypeName() const {
  return "framework.Animation";
}


// ===================================================================

#ifndef _MSC_VER
const int Symbol::kNameFieldNumber;
const int Symbol::kBoundingBoxFieldNumber;
const int Symbol::kFrameCountFieldNumber;
const int Symbol::kLayersFieldNumber;
const int Symbol::kAnisFieldNumber;
const int Symbol::kFrameRateFieldNumber;
const int Symbol::kPauseTimeFieldNumber;
#endif  // !_MSC_VER

Symbol::Symbol()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Symbol::InitAsDefaultInstance() {
  boundingbox_ = const_cast< ::framework::Rect*>(&::framework::Rect::default_instance());
}

Symbol::Symbol(const Symbol& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Symbol::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  boundingbox_ = NULL;
  framecount_ = 0;
  framerate_ = 0;
  pausetime_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Symbol::~Symbol() {
  SharedDtor();
}

void Symbol::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete boundingbox_;
  }
}

void Symbol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Symbol& Symbol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Symbol* Symbol::default_instance_ = NULL;

Symbol* Symbol::New() const {
  return new Symbol;
}

void Symbol::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_boundingbox()) {
      if (boundingbox_ != NULL) boundingbox_->::framework::Rect::Clear();
    }
    framecount_ = 0;
    framerate_ = 0;
    pausetime_ = 0;
  }
  layers_.Clear();
  anis_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Symbol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_boundingBox;
        break;
      }
      
      // required .framework.Rect boundingBox = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_boundingBox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_boundingbox()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_frameCount;
        break;
      }
      
      // required int32 frameCount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frameCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &framecount_)));
          set_has_framecount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_layers;
        break;
      }
      
      // repeated .framework.Layer layers = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_layers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_layers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_layers;
        if (input->ExpectTag(74)) goto parse_anis;
        break;
      }
      
      // repeated .framework.Animation anis = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_anis:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_anis()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_anis;
        if (input->ExpectTag(80)) goto parse_frameRate;
        break;
      }
      
      // optional int32 frameRate = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frameRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &framerate_)));
          set_has_framerate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_pauseTime;
        break;
      }
      
      // optional float pauseTime = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pauseTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pausetime_)));
          set_has_pausetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Symbol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required .framework.Rect boundingBox = 2;
  if (has_boundingbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->boundingbox(), output);
  }
  
  // required int32 frameCount = 3;
  if (has_framecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->framecount(), output);
  }
  
  // repeated .framework.Layer layers = 5;
  for (int i = 0; i < this->layers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->layers(i), output);
  }
  
  // repeated .framework.Animation anis = 9;
  for (int i = 0; i < this->anis_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->anis(i), output);
  }
  
  // optional int32 frameRate = 10;
  if (has_framerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->framerate(), output);
  }
  
  // optional float pauseTime = 11;
  if (has_pausetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->pausetime(), output);
  }
  
}

int Symbol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required .framework.Rect boundingBox = 2;
    if (has_boundingbox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->boundingbox());
    }
    
    // required int32 frameCount = 3;
    if (has_framecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->framecount());
    }
    
    // optional int32 frameRate = 10;
    if (has_framerate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->framerate());
    }
    
    // optional float pauseTime = 11;
    if (has_pausetime()) {
      total_size += 1 + 4;
    }
    
  }
  // repeated .framework.Layer layers = 5;
  total_size += 1 * this->layers_size();
  for (int i = 0; i < this->layers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->layers(i));
  }
  
  // repeated .framework.Animation anis = 9;
  total_size += 1 * this->anis_size();
  for (int i = 0; i < this->anis_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->anis(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Symbol::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Symbol*>(&from));
}

void Symbol::MergeFrom(const Symbol& from) {
  GOOGLE_CHECK_NE(&from, this);
  layers_.MergeFrom(from.layers_);
  anis_.MergeFrom(from.anis_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_boundingbox()) {
      mutable_boundingbox()->::framework::Rect::MergeFrom(from.boundingbox());
    }
    if (from.has_framecount()) {
      set_framecount(from.framecount());
    }
    if (from.has_framerate()) {
      set_framerate(from.framerate());
    }
    if (from.has_pausetime()) {
      set_pausetime(from.pausetime());
    }
  }
}

void Symbol::CopyFrom(const Symbol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Symbol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_boundingbox()) {
    if (!this->boundingbox().IsInitialized()) return false;
  }
  for (int i = 0; i < layers_size(); i++) {
    if (!this->layers(i).IsInitialized()) return false;
  }
  for (int i = 0; i < anis_size(); i++) {
    if (!this->anis(i).IsInitialized()) return false;
  }
  return true;
}

void Symbol::Swap(Symbol* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(boundingbox_, other->boundingbox_);
    std::swap(framecount_, other->framecount_);
    layers_.Swap(&other->layers_);
    anis_.Swap(&other->anis_);
    std::swap(framerate_, other->framerate_);
    std::swap(pausetime_, other->pausetime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Symbol::GetTypeName() const {
  return "framework.Symbol";
}


// ===================================================================

#ifndef _MSC_VER
const int Anim::kSymbolsFieldNumber;
#endif  // !_MSC_VER

Anim::Anim()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Anim::InitAsDefaultInstance() {
}

Anim::Anim(const Anim& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Anim::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Anim::~Anim() {
  SharedDtor();
}

void Anim::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Anim::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Anim& Anim::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Anim* Anim::default_instance_ = NULL;

Anim* Anim::New() const {
  return new Anim;
}

void Anim::Clear() {
  symbols_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Anim::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .framework.Symbol symbols = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_symbols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_symbols()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_symbols;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Anim::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .framework.Symbol symbols = 1;
  for (int i = 0; i < this->symbols_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->symbols(i), output);
  }
  
}

int Anim::ByteSize() const {
  int total_size = 0;
  
  // repeated .framework.Symbol symbols = 1;
  total_size += 1 * this->symbols_size();
  for (int i = 0; i < this->symbols_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->symbols(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Anim::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Anim*>(&from));
}

void Anim::MergeFrom(const Anim& from) {
  GOOGLE_CHECK_NE(&from, this);
  symbols_.MergeFrom(from.symbols_);
}

void Anim::CopyFrom(const Anim& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Anim::IsInitialized() const {
  
  for (int i = 0; i < symbols_size(); i++) {
    if (!this->symbols(i).IsInitialized()) return false;
  }
  return true;
}

void Anim::Swap(Anim* other) {
  if (other != this) {
    symbols_.Swap(&other->symbols_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Anim::GetTypeName() const {
  return "framework.Anim";
}


// ===================================================================

#ifndef _MSC_VER
const int AnimIndexItem::kNameFieldNumber;
const int AnimIndexItem::kSymbolsFieldNumber;
#endif  // !_MSC_VER

AnimIndexItem::AnimIndexItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AnimIndexItem::InitAsDefaultInstance() {
}

AnimIndexItem::AnimIndexItem(const AnimIndexItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AnimIndexItem::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AnimIndexItem::~AnimIndexItem() {
  SharedDtor();
}

void AnimIndexItem::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void AnimIndexItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AnimIndexItem& AnimIndexItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

AnimIndexItem* AnimIndexItem::default_instance_ = NULL;

AnimIndexItem* AnimIndexItem::New() const {
  return new AnimIndexItem;
}

void AnimIndexItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  symbols_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AnimIndexItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_symbols;
        break;
      }
      
      // repeated string symbols = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_symbols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_symbols()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_symbols;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AnimIndexItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // repeated string symbols = 2;
  for (int i = 0; i < this->symbols_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->symbols(i), output);
  }
  
}

int AnimIndexItem::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  // repeated string symbols = 2;
  total_size += 1 * this->symbols_size();
  for (int i = 0; i < this->symbols_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->symbols(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AnimIndexItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AnimIndexItem*>(&from));
}

void AnimIndexItem::MergeFrom(const AnimIndexItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  symbols_.MergeFrom(from.symbols_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void AnimIndexItem::CopyFrom(const AnimIndexItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnimIndexItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void AnimIndexItem::Swap(AnimIndexItem* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    symbols_.Swap(&other->symbols_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AnimIndexItem::GetTypeName() const {
  return "framework.AnimIndexItem";
}


// ===================================================================

#ifndef _MSC_VER
const int AnimIndex::kAnimsFieldNumber;
#endif  // !_MSC_VER

AnimIndex::AnimIndex()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AnimIndex::InitAsDefaultInstance() {
}

AnimIndex::AnimIndex(const AnimIndex& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AnimIndex::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AnimIndex::~AnimIndex() {
  SharedDtor();
}

void AnimIndex::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AnimIndex::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AnimIndex& AnimIndex::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

AnimIndex* AnimIndex::default_instance_ = NULL;

AnimIndex* AnimIndex::New() const {
  return new AnimIndex;
}

void AnimIndex::Clear() {
  anims_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AnimIndex::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .framework.AnimIndexItem anims = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_anims:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_anims()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_anims;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AnimIndex::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .framework.AnimIndexItem anims = 1;
  for (int i = 0; i < this->anims_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->anims(i), output);
  }
  
}

int AnimIndex::ByteSize() const {
  int total_size = 0;
  
  // repeated .framework.AnimIndexItem anims = 1;
  total_size += 1 * this->anims_size();
  for (int i = 0; i < this->anims_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->anims(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AnimIndex::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AnimIndex*>(&from));
}

void AnimIndex::MergeFrom(const AnimIndex& from) {
  GOOGLE_CHECK_NE(&from, this);
  anims_.MergeFrom(from.anims_);
}

void AnimIndex::CopyFrom(const AnimIndex& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnimIndex::IsInitialized() const {
  
  for (int i = 0; i < anims_size(); i++) {
    if (!this->anims(i).IsInitialized()) return false;
  }
  return true;
}

void AnimIndex::Swap(AnimIndex* other) {
  if (other != this) {
    anims_.Swap(&other->anims_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AnimIndex::GetTypeName() const {
  return "framework.AnimIndex";
}


// ===================================================================

#ifndef _MSC_VER
const int Frame::kNameFieldNumber;
const int Frame::kXFieldNumber;
const int Frame::kYFieldNumber;
const int Frame::kWFieldNumber;
const int Frame::kHFieldNumber;
const int Frame::kRotatedFieldNumber;
const int Frame::kFilenameFieldNumber;
#endif  // !_MSC_VER

Frame::Frame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Frame::InitAsDefaultInstance() {
}

Frame::Frame(const Frame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Frame::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  x_ = 0;
  y_ = 0;
  w_ = 0;
  h_ = 0;
  rotated_ = false;
  filename_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame::~Frame() {
  SharedDtor();
}

void Frame::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Frame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Frame& Frame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

Frame* Frame::default_instance_ = NULL;

Frame* Frame::New() const {
  return new Frame;
}

void Frame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    x_ = 0;
    y_ = 0;
    w_ = 0;
    h_ = 0;
    rotated_ = false;
    filename_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }
      
      // required int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }
      
      // required int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_w;
        break;
      }
      
      // required int32 w = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_h;
        break;
      }
      
      // required int32 h = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_h:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &h_)));
          set_has_h();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_rotated;
        break;
      }
      
      // required bool rotated = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rotated:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rotated_)));
          set_has_rotated();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_filename;
        break;
      }
      
      // required int32 filename = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filename:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &filename_)));
          set_has_filename();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }
  
  // required int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }
  
  // required int32 w = 4;
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->w(), output);
  }
  
  // required int32 h = 5;
  if (has_h()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->h(), output);
  }
  
  // required bool rotated = 6;
  if (has_rotated()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->rotated(), output);
  }
  
  // required int32 filename = 7;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->filename(), output);
  }
  
}

int Frame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }
    
    // required int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }
    
    // required int32 w = 4;
    if (has_w()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->w());
    }
    
    // required int32 h = 5;
    if (has_h()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->h());
    }
    
    // required bool rotated = 6;
    if (has_rotated()) {
      total_size += 1 + 1;
    }
    
    // required int32 filename = 7;
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->filename());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Frame*>(&from));
}

void Frame::MergeFrom(const Frame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
    if (from.has_h()) {
      set_h(from.h());
    }
    if (from.has_rotated()) {
      set_rotated(from.rotated());
    }
    if (from.has_filename()) {
      set_filename(from.filename());
    }
  }
}

void Frame::CopyFrom(const Frame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;
  
  return true;
}

void Frame::Swap(Frame* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(w_, other->w_);
    std::swap(h_, other->h_);
    std::swap(rotated_, other->rotated_);
    std::swap(filename_, other->filename_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Frame::GetTypeName() const {
  return "framework.Frame";
}


// ===================================================================

#ifndef _MSC_VER
const int FrameList::kFramesFieldNumber;
const int FrameList::kFilenamesFieldNumber;
#endif  // !_MSC_VER

FrameList::FrameList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FrameList::InitAsDefaultInstance() {
}

FrameList::FrameList(const FrameList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FrameList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameList::~FrameList() {
  SharedDtor();
}

void FrameList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FrameList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FrameList& FrameList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_anim_2eproto();  return *default_instance_;
}

FrameList* FrameList::default_instance_ = NULL;

FrameList* FrameList::New() const {
  return new FrameList;
}

void FrameList::Clear() {
  frames_.Clear();
  filenames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FrameList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .framework.Frame frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_frames;
        if (input->ExpectTag(18)) goto parse_filenames;
        break;
      }
      
      // repeated string filenames = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filenames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filenames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_filenames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .framework.Frame frames = 1;
  for (int i = 0; i < this->frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->frames(i), output);
  }
  
  // repeated string filenames = 2;
  for (int i = 0; i < this->filenames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->filenames(i), output);
  }
  
}

int FrameList::ByteSize() const {
  int total_size = 0;
  
  // repeated .framework.Frame frames = 1;
  total_size += 1 * this->frames_size();
  for (int i = 0; i < this->frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frames(i));
  }
  
  // repeated string filenames = 2;
  total_size += 1 * this->filenames_size();
  for (int i = 0; i < this->filenames_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filenames(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FrameList*>(&from));
}

void FrameList::MergeFrom(const FrameList& from) {
  GOOGLE_CHECK_NE(&from, this);
  frames_.MergeFrom(from.frames_);
  filenames_.MergeFrom(from.filenames_);
}

void FrameList::CopyFrom(const FrameList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameList::IsInitialized() const {
  
  for (int i = 0; i < frames_size(); i++) {
    if (!this->frames(i).IsInitialized()) return false;
  }
  return true;
}

void FrameList::Swap(FrameList* other) {
  if (other != this) {
    frames_.Swap(&other->frames_);
    filenames_.Swap(&other->filenames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FrameList::GetTypeName() const {
  return "framework.FrameList";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace framework

// @@protoc_insertion_point(global_scope)
